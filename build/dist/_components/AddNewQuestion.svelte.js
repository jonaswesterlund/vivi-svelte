import './AddNewQuestion.svelte.css.proxy.js';
/* src\_components\AddNewQuestion.svelte generated by Svelte v3.37.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	component_subscribe,
	destroy_block,
	destroy_each,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	select_option,
	select_value,
	set_data,
	set_input_value,
	set_store_value,
	space,
	text,
	toggle_class,
	update_keyed_each
} from "../../_snowpack/pkg/svelte/internal.js";

import axios from "../../_snowpack/pkg/axios.js";
import { categories, questions } from "../stores.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[22] = list;
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (63:4) {:else}
function create_else_block(ctx) {
	let div;
	let each_value_2 = /*selectedCategories*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "flex flex-wrap w-full my-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*selectedCategories*/ 2) {
				each_value_2 = /*selectedCategories*/ ctx[1];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (61:4) {#if selectedCategories.length === 0}
function create_if_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "Välj åtminstone en kategori!";
			attr(div, "class", "my-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (65:8) {#each selectedCategories as selectedCategory}
function create_each_block_2(ctx) {
	let span;
	let t0_value = /*selectedCategory*/ ctx[7].name + "";
	let t0;
	let t1;
	let button;
	let t3;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[11](/*selectedCategory*/ ctx[7]);
	}

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			button = element("button");
			button.textContent = "x";
			t3 = space();
			attr(button, "class", "rounded-full border border-blue-700 px-1 ml-1\r\n              focus:outline-none");
			attr(span, "class", "border-blue-600 rounded-full border-2 px-4 py-1 mr-2 mb-2\r\n            cursor-default");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, button);
			append(span, t3);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*selectedCategories*/ 2 && t0_value !== (t0_value = /*selectedCategory*/ ctx[7].name + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (87:8) {#each $categories as category}
function create_each_block_1(ctx) {
	let option;
	let t_value = /*category*/ ctx[24].name + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*category*/ ctx[24];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$categories*/ 64 && t_value !== (t_value = /*category*/ ctx[24].name + "")) set_data(t, t_value);

			if (dirty & /*$categories*/ 64 && option_value_value !== (option_value_value = /*category*/ ctx[24])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (115:6) {#each answerChoices as choice, i (choice.id)}
function create_each_block(key_1, ctx) {
	let div3;
	let div1;
	let label0;
	let t0;
	let t1_value = /*i*/ ctx[23] + 1 + "";
	let t1;
	let t2;
	let button;
	let t4;
	let div0;
	let textarea;
	let t5;
	let div2;
	let label1;
	let input;
	let input_value_value;
	let t6;
	let t7;
	let mounted;
	let dispose;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[14](/*choice*/ ctx[21]);
	}

	function textarea_input_handler() {
		/*textarea_input_handler*/ ctx[15].call(textarea, /*each_value*/ ctx[22], /*i*/ ctx[23]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			div3 = element("div");
			div1 = element("div");
			label0 = element("label");
			t0 = text("Svar ");
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			button.textContent = "Ta bort";
			t4 = space();
			div0 = element("div");
			textarea = element("textarea");
			t5 = space();
			div2 = element("div");
			label1 = element("label");
			input = element("input");
			t6 = text("\r\n              Rätt svar");
			t7 = space();
			attr(button, "class", "rounded-full border border-blue-700 px-2 py-1 ml-4\r\n                focus:outline-none");
			attr(textarea, "class", "border border-gray-600 w-full rounded p-2");
			attr(div0, "class", "my-2");
			attr(label0, "class", "font-semibold");
			attr(input, "type", "radio");
			input.__value = input_value_value = /*i*/ ctx[23];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[17][0].push(input);
			attr(div3, "class", "w-full mb-4");
			this.first = div3;
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, label0);
			append(label0, t0);
			append(label0, t1);
			append(label0, t2);
			append(label0, button);
			append(label0, t4);
			append(label0, div0);
			append(div0, textarea);
			set_input_value(textarea, /*choice*/ ctx[21].answer);
			append(div3, t5);
			append(div3, div2);
			append(div2, label1);
			append(label1, input);
			input.checked = input.__value === /*correctAnswerChoice*/ ctx[2];
			append(label1, t6);
			append(div3, t7);

			if (!mounted) {
				dispose = [
					listen(button, "click", click_handler_2),
					listen(textarea, "input", textarea_input_handler),
					listen(input, "change", /*input_change_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*answerChoices*/ 32 && t1_value !== (t1_value = /*i*/ ctx[23] + 1 + "")) set_data(t1, t1_value);

			if (dirty & /*answerChoices*/ 32) {
				set_input_value(textarea, /*choice*/ ctx[21].answer);
			}

			if (dirty & /*answerChoices*/ 32 && input_value_value !== (input_value_value = /*i*/ ctx[23])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty & /*correctAnswerChoice*/ 4) {
				input.checked = input.__value === /*correctAnswerChoice*/ ctx[2];
			}
		},
		d(detaching) {
			if (detaching) detach(div3);
			/*$$binding_groups*/ ctx[17][0].splice(/*$$binding_groups*/ ctx[17][0].indexOf(input), 1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div15;
	let div1;
	let h10;
	let t1;
	let div0;
	let button0;
	let t3;
	let div3;
	let label0;
	let t4;
	let div2;
	let textarea0;
	let t5;
	let div4;
	let h11;
	let t7;
	let t8;
	let div7;
	let div5;
	let select;
	let option;
	let option_value_value;
	let t10;
	let div6;
	let button1;
	let t12;
	let div14;
	let h12;
	let t14;
	let div8;
	let button2;
	let t16;
	let div9;
	let each_blocks = [];
	let each1_lookup = new Map();
	let t17;
	let div11;
	let label1;
	let t18;
	let div10;
	let textarea1;
	let t19;
	let div13;
	let label2;
	let t20;
	let div12;
	let textarea2;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*selectedCategories*/ ctx[1].length === 0) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);
	let each_value_1 = /*$categories*/ ctx[6];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*answerChoices*/ ctx[5];
	const get_key = ctx => /*choice*/ ctx[21].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div15 = element("div");
			div1 = element("div");
			h10 = element("h1");
			h10.textContent = "Ny fråga";
			t1 = space();
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Spara";
			t3 = space();
			div3 = element("div");
			label0 = element("label");
			t4 = text("Fråga\r\n      ");
			div2 = element("div");
			textarea0 = element("textarea");
			t5 = space();
			div4 = element("div");
			h11 = element("h1");
			h11.textContent = "Kategorier";
			t7 = space();
			if_block.c();
			t8 = space();
			div7 = element("div");
			div5 = element("div");
			select = element("select");
			option = element("option");
			option.textContent = "Välj kategori";

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t10 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = "Lägg till kategori";
			t12 = space();
			div14 = element("div");
			h12 = element("h1");
			h12.textContent = "Svarsalternativ";
			t14 = space();
			div8 = element("div");
			button2 = element("button");
			button2.textContent = "Lägg till svarsalternativ";
			t16 = space();
			div9 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t17 = space();
			div11 = element("div");
			label1 = element("label");
			t18 = text("Förklaring (rätt svar)\r\n        ");
			div10 = element("div");
			textarea1 = element("textarea");
			t19 = space();
			div13 = element("div");
			label2 = element("label");
			t20 = text("Förklaring (fel svar)\r\n        ");
			div12 = element("div");
			textarea2 = element("textarea");
			attr(h10, "class", "text-xl font-semibold mb-2");
			attr(button0, "class", "border-blue-700 rounded border-2 px-4 py-1 mr-2\r\n        focus:outline-none hover:bg-blue-700 hover:text-white");
			attr(div1, "class", "flex justify-between align-top");
			attr(textarea0, "class", "border border-gray-600 w-full rounded p-2");
			attr(div2, "class", "my-2");
			attr(label0, "class", "font-semibold text-lg");
			attr(h11, "class", "font-semibold text-lg");
			option.__value = option_value_value = null;
			option.value = option.__value;
			option.selected = true;
			option.disabled = true;
			option.hidden = true;
			attr(select, "class", "appearance-none w-full border border-gray-600 p-1 rounded");
			if (/*selectedCategory*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[12].call(select));
			attr(button1, "class", "border-blue-700 rounded border-2 px-4 py-1 mr-2\r\n        focus:outline-none hover:bg-blue-700 hover:text-white svelte-suqtex");
			toggle_class(button1, "btn-disabled", !/*selectedCategory*/ ctx[7] || /*selectedCategories*/ ctx[1].includes(/*selectedCategory*/ ctx[7]));
			attr(div6, "class", "my-2");
			attr(h12, "class", "text-lg font-semibold");
			attr(button2, "class", "border-blue-700 rounded border-2 px-4 py-1 mr-2\r\n        focus:outline-none hover:bg-blue-700 hover:text-white");
			attr(div8, "class", "my-2");
			attr(textarea1, "class", "border border-gray-600 w-full rounded p-2");
			attr(div10, "class", "my-2");
			attr(label1, "class", "font-semibold text-lg");
			attr(textarea2, "class", "border border-gray-600 w-full rounded p-2");
			attr(div12, "class", "my-2");
			attr(label2, "class", "font-semibold text-lg");
			attr(div14, "class", "mt-6");
			attr(div15, "class", "flex-1 my-8 border-2 border-gray-600 shadow-xl p-4 mx-10");
		},
		m(target, anchor) {
			insert(target, div15, anchor);
			append(div15, div1);
			append(div1, h10);
			append(div1, t1);
			append(div1, div0);
			append(div0, button0);
			append(div15, t3);
			append(div15, div3);
			append(div3, label0);
			append(label0, t4);
			append(label0, div2);
			append(div2, textarea0);
			set_input_value(textarea0, /*questionContent*/ ctx[0]);
			append(div15, t5);
			append(div15, div4);
			append(div4, h11);
			append(div4, t7);
			if_block.m(div4, null);
			append(div15, t8);
			append(div15, div7);
			append(div7, div5);
			append(div5, select);
			append(select, option);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(select, null);
			}

			select_option(select, /*selectedCategory*/ ctx[7]);
			append(div7, t10);
			append(div7, div6);
			append(div6, button1);
			append(div15, t12);
			append(div15, div14);
			append(div14, h12);
			append(div14, t14);
			append(div14, div8);
			append(div8, button2);
			append(div14, t16);
			append(div14, div9);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div9, null);
			}

			append(div14, t17);
			append(div14, div11);
			append(div11, label1);
			append(label1, t18);
			append(label1, div10);
			append(div10, textarea1);
			set_input_value(textarea1, /*correctAnswerRationale*/ ctx[3]);
			append(div14, t19);
			append(div14, div13);
			append(div13, label2);
			append(label2, t20);
			append(label2, div12);
			append(div12, textarea2);
			set_input_value(textarea2, /*incorrectAnswerRationale*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*saveQuestion*/ ctx[9]),
					listen(textarea0, "input", /*textarea0_input_handler*/ ctx[10]),
					listen(select, "change", /*select_change_handler*/ ctx[12]),
					listen(button1, "click", /*addCategory*/ ctx[8]),
					listen(button2, "click", /*click_handler_1*/ ctx[13]),
					listen(textarea1, "input", /*textarea1_input_handler*/ ctx[18]),
					listen(textarea2, "input", /*textarea2_input_handler*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*questionContent*/ 1) {
				set_input_value(textarea0, /*questionContent*/ ctx[0]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div4, null);
				}
			}

			if (dirty & /*$categories*/ 64) {
				each_value_1 = /*$categories*/ ctx[6];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(select, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*selectedCategory, $categories*/ 192) {
				select_option(select, /*selectedCategory*/ ctx[7]);
			}

			if (dirty & /*selectedCategory, selectedCategories*/ 130) {
				toggle_class(button1, "btn-disabled", !/*selectedCategory*/ ctx[7] || /*selectedCategories*/ ctx[1].includes(/*selectedCategory*/ ctx[7]));
			}

			if (dirty & /*answerChoices, correctAnswerChoice*/ 36) {
				each_value = /*answerChoices*/ ctx[5];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, div9, destroy_block, create_each_block, null, get_each_context);
			}

			if (dirty & /*correctAnswerRationale*/ 8) {
				set_input_value(textarea1, /*correctAnswerRationale*/ ctx[3]);
			}

			if (dirty & /*incorrectAnswerRationale*/ 16) {
				set_input_value(textarea2, /*incorrectAnswerRationale*/ ctx[4]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div15);
			if_block.d();
			destroy_each(each_blocks_1, detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $questions;
	let $categories;
	component_subscribe($$self, questions, $$value => $$invalidate(20, $questions = $$value));
	component_subscribe($$self, categories, $$value => $$invalidate(6, $categories = $$value));
	let questionContent = "";
	let selectedCategories = [];
	let selectedCategory;
	let correctAnswerChoice;
	let correctAnswerRationale;
	let incorrectAnswerRationale;
	let answerChoices = [];

	function addCategory() {
		if (selectedCategory && !selectedCategories.includes(selectedCategory)) {
			$$invalidate(1, selectedCategories = [...selectedCategories, selectedCategory]);
		}
	}

	async function saveQuestion() {
		const response = await axios.post("http://localhost:8081/api/questions", {
			content: questionContent,
			categoryIds: selectedCategories.map(c => c.id),
			answerChoices,
			correctAnswerChoice,
			correctAnswerRationale,
			incorrectAnswerRationale
		});

		set_store_value(questions, $questions = [...$questions, response.data], $questions);
	}

	const $$binding_groups = [[]];

	function textarea0_input_handler() {
		questionContent = this.value;
		$$invalidate(0, questionContent);
	}

	const click_handler = selectedCategory => $$invalidate(1, selectedCategories = selectedCategories.filter(c => c !== selectedCategory));

	function select_change_handler() {
		selectedCategory = select_value(this);
		$$invalidate(7, selectedCategory);
	}

	const click_handler_1 = () => {
		$$invalidate(5, answerChoices = [...answerChoices, { id: answerChoices.length + 1, answer: "" }]);
	};

	const click_handler_2 = choice => $$invalidate(5, answerChoices = answerChoices.filter(ac => ac.id !== choice.id));

	function textarea_input_handler(each_value, i) {
		each_value[i].answer = this.value;
		$$invalidate(5, answerChoices);
	}

	function input_change_handler() {
		correctAnswerChoice = this.__value;
		$$invalidate(2, correctAnswerChoice);
	}

	function textarea1_input_handler() {
		correctAnswerRationale = this.value;
		$$invalidate(3, correctAnswerRationale);
	}

	function textarea2_input_handler() {
		incorrectAnswerRationale = this.value;
		$$invalidate(4, incorrectAnswerRationale);
	}

	return [
		questionContent,
		selectedCategories,
		correctAnswerChoice,
		correctAnswerRationale,
		incorrectAnswerRationale,
		answerChoices,
		$categories,
		selectedCategory,
		addCategory,
		saveQuestion,
		textarea0_input_handler,
		click_handler,
		select_change_handler,
		click_handler_1,
		click_handler_2,
		textarea_input_handler,
		input_change_handler,
		$$binding_groups,
		textarea1_input_handler,
		textarea2_input_handler
	];
}

class AddNewQuestion extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default AddNewQuestion;